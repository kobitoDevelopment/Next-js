# アーキテクチャレビュー

## 総評

このプロジェクトは Next.js 15 を使用した Todo アプリケーションですが、複数の実装パターンが混在しており、アーキテクチャの一貫性に欠けています。早急に統一されたアーキテクチャパターンの採用が必要です。

## 重大な問題点

### 1. 認証パターンの不統一
- **問題**: Route Handlers と Server Actions の両方が実装されている
- **影響**: メンテナンス性の低下、バグの温床
- **推奨**: Server Actions に統一する

### 2. Next.js 15 のセキュリティ脆弱性への対応不足
- **問題**: ミドルウェアベースの認証を使用している（CVE-2025-29927）
- **影響**: セキュリティリスク
- **推奨**: Data Access Layer (DAL) パターンへの移行

### 3. コンポーネントの重複実装
- **問題**: `signin` と `signin2`、`signup` と `signup2` など複数バージョンが存在
- **影響**: コードの肥大化、保守コストの増大
- **推奨**: 不要なバージョンの削除と統一

## アーキテクチャ改善提案

### 1. Data Access Layer の導入

```typescript
// src/lib/dal/index.ts
export class DataAccessLayer {
  async getUser(userId: string) {
    // 認証チェック
    const session = await getSession();
    if (!session) throw new Error('Unauthorized');
    
    // データアクセス
    const { data, error } = await supabase
      .from('users')
      .select('*')
      .eq('id', userId)
      .single();
      
    return data;
  }
}
```

### 2. Feature-Sliced Design の採用

```
src/
├── features/           # 機能別モジュール
│   ├── auth/
│   │   ├── ui/        # UIコンポーネント
│   │   ├── model/     # ビジネスロジック
│   │   └── api/       # API通信
│   ├── todos/
│   └── admin/
├── shared/            # 共通モジュール
└── app/              # Next.jsルーティング
```

### 3. 統一された認証フロー

```typescript
// src/features/auth/model/auth.ts
export class AuthService {
  private dal = new DataAccessLayer();
  
  async signIn(email: string, password: string) {
    // 1. バリデーション
    const validated = await signInSchema.parseAsync({ email, password });
    
    // 2. 認証処理
    const user = await this.dal.authenticateUser(validated);
    
    // 3. セッション作成
    await this.createSession(user);
    
    return user;
  }
}
```

## 状態管理の改善

### 現状の問題
- Context API の使用が限定的
- クライアント側とサーバー側の状態管理が不整合

### 改善案
```typescript
// src/features/auth/model/store.ts
export const useAuthStore = create<AuthState>((set) => ({
  user: null,
  isLoading: true,
  setUser: (user) => set({ user, isLoading: false }),
  clearUser: () => set({ user: null, isLoading: false }),
}));
```

## 型定義の統一

### 現状の問題
- 複数の場所で User 型が定義されている
- 型定義ファイルの構造が不統一

### 改善案
```typescript
// src/shared/types/index.ts
export interface User {
  id: string;
  email: string;
  role: 'admin' | 'user';
  created_at: string;
  updated_at: string;
}

// Zodスキーマとの統合
export const userSchema = z.object({
  id: z.string().uuid(),
  email: z.string().email(),
  role: z.enum(['admin', 'user']),
  created_at: z.string().datetime(),
  updated_at: z.string().datetime(),
});

export type UserType = z.infer<typeof userSchema>;
```

## パフォーマンス最適化

### 1. 動的インポートの活用
```typescript
const AdminPanel = dynamic(() => import('@/features/admin/ui/Panel'), {
  loading: () => <Skeleton />,
  ssr: false,
});
```

### 2. React Server Components の最大活用
```typescript
// src/app/todos/page.tsx
export default async function TodosPage() {
  const todos = await getTodos(); // サーバー側でデータ取得
  return <TodoList todos={todos} />;
}
```

## 推奨アクションアイテム

1. **短期（1-2週間）**
   - 重複コンポーネントの削除
   - 型定義の統一
   - テストカバレッジの向上

2. **中期（1ヶ月）**
   - Data Access Layer の実装
   - Feature-Sliced Design への移行
   - 認証フローの統一

3. **長期（2-3ヶ月）**
   - パフォーマンス最適化
   - モニタリングの導入
   - ドキュメント整備